<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Dream: Red Sedan V4.4.5</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; touch-action: none; user-select: none; }
        #joystick-wrapper { position: absolute; bottom: 40px; left: 40px; width: 100px; height: 100px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 50%; z-index: 10; display: flex; align-items: center; justify-content: center; }
        #joystick-knob { width: 40px; height: 40px; background: #ff0000; border-radius: 50%; position: absolute; pointer-events: none; }
        #brake-btn { position: absolute; bottom: 40px; right: 40px; width: 80px; height: 80px; background: rgba(255,0,0,0.1); border: 1px solid #ff0000; border-radius: 12px; color: #ff0000; font-weight: bold; display: flex; align-items: center; justify-content: center; z-index: 10; }
        #mp-panel { position: absolute; top: 20px; right: 20px; width: 250px; background: rgba(0,0,0,0.9); border: 1px solid #444; color: #fff; z-index: 20; border-radius: 4px; overflow: hidden; }
        #mp-header { background: #ff0000; color: #000; padding: 8px; font-weight: bold; cursor: pointer; display: flex; justify-content: space-between; }
        #mp-content { padding: 12px; display: none; flex-direction: column; gap: 10px; }
        #mp-content.open { display: flex; }
        input { background: #111; border: 1px solid #444; color: #ff0000; padding: 5px; font-family: monospace; outline: none; width: calc(100% - 12px); }
        .btn { background: #222; border: 1px solid #ff0000; color: #fff; padding: 5px; cursor: pointer; text-align: center; font-size: 11px; }
        #ui { position: absolute; top: 20px; left: 20px; color: #fff; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 4px; font-size: 11px; border-left: 2px solid #ff0000; pointer-events: none; z-index: 5; }
    </style>
</head>
<body>

<div id="mp-panel">
    <div id="mp-header" onclick="document.getElementById('mp-content').classList.toggle('open')">
        <span>MULTIPLAYER</span>
        <span>â–¼</span>
    </div>
    <div id="mp-content">
        <label>USERNAME:</label>
        <input type="text" id="username-in" maxlength="24">
        <hr style="border:0; border-top:1px solid #333; width:100%">
        <label>JOIN PEER ID:</label>
        <input type="text" id="join-seed" placeholder="Paste Peer ID here...">
        <div class="btn" onclick="connectToPeer()">JOIN SESSION</div>
        <div id="conn-status" style="font-size:9px; color:#ff0000">Status: Offline</div>
        <div id="peer-id-display" style="font-size:9px; color:#ff0000; margin-top:5px; word-break:break-all; cursor:pointer" onclick="copyMyId()">MY ID (TAP TO COPY): Generating...</div>
    </div>
</div>

<div id="joystick-wrapper"><div id="joystick-knob"></div></div>
<div id="brake-btn">BRAKE</div>
<div id="ui">
    RED SEDAN | V4.4.5<br>
    SPEED: <span id="speed-val">0</span> KM/H<br>
    X: <span id="pos-x">0</span><br>
    Z: <span id="pos-z">0</span><br>
    STABILITY: <span id="recovery-status">ACTIVE</span>
</div>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
            "simplex-noise": "https://cdn.skypack.dev/simplex-noise@2.4.0"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
    import * as CANNON from 'cannon-es';
    import SimplexNoise from 'simplex-noise';

    const DATA_RES = 1024, GRID_SIZE = 1200, AMPLITUDE = 40, FREQ = 0.0015, WHEEL_RADIUS = 0.5; 
    const MASS = 6.8e14, MAX_SPEED_KMH = 650;

    const randomSuffix = Math.floor(Math.random() * 99999) + 1;
    document.getElementById('username-in').value = "Driver" + randomSuffix.toString().padStart(5, '0');

    let currentWorldSeed = Math.floor(1000 + Math.random() * 9000);
    let simplex = new SimplexNoise(currentWorldSeed);
    let amIPeer = false; 

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 15000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const sun = new THREE.DirectionalLight(0xffffff, 2.5);
    sun.position.set(50, 100, 50);
    scene.add(sun, new THREE.AmbientLight(0xffffff, 0.4));

    const world = new CANNON.World();
    world.gravity.set(0, -150, 0);
    world.solver.iterations = 100;

    const groundMat = new CANNON.Material("ground"), carMat = new CANNON.Material("car");
    world.addContactMaterial(new CANNON.ContactMaterial(groundMat, carMat, {
        friction: 0.1, restitution: 0.0, contactEquationStiffness: 1e20, contactEquationRelaxation: 5
    }));

    function getHeight(x, z) { return simplex.noise2D(x * FREQ, z * FREQ) * AMPLITUDE; }
    const terrainGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, DATA_RES - 1, DATA_RES - 1);
    terrainGeo.rotateX(-Math.PI / 2);
    const terrainMesh = new THREE.Mesh(terrainGeo, new THREE.MeshStandardMaterial({ color: 0x444444, wireframe: true }));
    scene.add(terrainMesh);

    let hfBody = null;
    const elementSize = GRID_SIZE / (DATA_RES - 1);
    function syncTerrain(cx, cz) {
        const step = GRID_SIZE / 4; 
        const snapX = Math.floor(cx / step) * step, snapZ = Math.floor(cz / step) * step;
        terrainMesh.position.set(snapX, 0, snapZ);
        const matrix = [];
        for (let i = 0; i < DATA_RES; i++) {
            matrix.push(new Float32Array(DATA_RES));
            for (let j = 0; j < DATA_RES; j++) {
                const wx = snapX - (GRID_SIZE / 2) + (i * elementSize);
                const wz = snapZ - (GRID_SIZE / 2) + (j * elementSize);
                matrix[i][DATA_RES - 1 - j] = getHeight(wx, wz) + 0.1; 
            }
        }
        const posAttr = terrainGeo.attributes.position;
        for (let i = 0; i < posAttr.count; i++) posAttr.setY(i, getHeight(posAttr.getX(i) + snapX, posAttr.getZ(i) + snapZ));
        posAttr.needsUpdate = true;
        if (hfBody) world.removeBody(hfBody);
        hfBody = new CANNON.Body({ mass: 0, material: groundMat });
        hfBody.addShape(new CANNON.Heightfield(matrix, { elementSize: elementSize }));
        hfBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        hfBody.position.set(snapX - GRID_SIZE/2, 0, snapZ + GRID_SIZE/2);
        world.addBody(hfBody);
    }

    function performResetAndSync(newSeed) {
        chassisBody.velocity.set(0, 0, 0);
        chassisBody.angularVelocity.set(0, 0, 0);
        chassisBody.position.set(0, 20, 0);
        chassisBody.quaternion.set(0, 0, 0, 1);
        currentWorldSeed = newSeed;
        simplex = new SimplexNoise(currentWorldSeed);
        syncTerrain(0, 0);
    }

    const chassisBody = new CANNON.Body({ mass: MASS, material: carMat });
    chassisBody.addShape(new CANNON.Box(new CANNON.Vec3(1.4, 0.8, 2.8)));
    chassisBody.position.set(0, 20, 0);
    chassisBody.angularDamping = 0.95;
    chassisBody.linearDamping = 0.05;

    const vehicle = new CANNON.RaycastVehicle({ chassisBody, indexForwardAxis: 2, indexRightAxis: 0, indexUpAxis: 1 });
    const wOpts = { radius: WHEEL_RADIUS, directionLocal: new CANNON.Vec3(0, -1, 0), suspensionStiffness: 500, suspensionRestLength: 1.1, frictionSlip: 50.0, dampingRelaxation: 20, dampingCompression: 15, axleLocal: new CANNON.Vec3(-1, 0, 0) };
    [[1.2, 0, 1.6], [-1.2, 0, 1.6], [1.2, 0, -1.725], [-1.2, 0, -1.725]].forEach(p => { wOpts.chassisConnectionPointLocal = new CANNON.Vec3(...p); vehicle.addWheel(wOpts); });
    vehicle.addToWorld(world);

    const localCarMesh = new THREE.Group();
    scene.add(localCarMesh);
    const loader = new GLTFLoader();
    let carModel, wheelModel;
    const wheelMeshes = [];

    loader.load('https://raw.githubusercontent.com/moo2645m/car-glb/main/scene.glb', (gltf) => { 
        carModel = gltf.scene; carModel.scale.set(3,3,3); carModel.position.set(0, -0.5, 0.2);
        localCarMesh.add(SkeletonUtils.clone(carModel));
    });

    loader.load('https://raw.githubusercontent.com/moo2645m/wheel-glb/main/Tire.glb', (gltf) => {
        wheelModel = gltf.scene;
        const s = WHEEL_RADIUS * 0.8;
        for (let i = 0; i < 4; i++) {
            const wGroup = new THREE.Group();
            const wModel = SkeletonUtils.clone(wheelModel);
            wModel.scale.set(s, s, s);
            wGroup.add(wModel);
            scene.add(wGroup);
            wheelMeshes[i] = wGroup;
        }
    });

    function createNameTag(name) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512; canvas.height = 128;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 40, 512, 60);
        ctx.font = 'bold 48px monospace';
        ctx.fillStyle = '#ff0000';
        ctx.textAlign = 'center';
        ctx.fillText(name.toUpperCase(), 256, 85);
        const tex = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
        sprite.scale.set(4, 1, 1);
        sprite.position.y = 2.5;
        sprite.userData.name = name;
        return sprite;
    }

    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.minDistance = 8; orbit.maxDistance = 20;

    let peer, myId, connections = {}, remotePlayers = {};
    const usernameInput = document.getElementById('username-in');

    function initMultiplayer() {
        peer = new Peer({ debug: 1 });
        peer.on('open', (id) => { 
            myId = id; 
            document.getElementById('peer-id-display').innerText = "MY ID (TAP TO COPY): " + id; 
            document.getElementById('conn-status').innerText = "Status: Online";
            document.getElementById('conn-status').style.color = "#00ff00";
        });
        peer.on('connection', (conn) => setupConn(conn, false));
        peer.on('error', (err) => { document.getElementById('conn-status').innerText = "Error: " + err.type; });
    }

    window.copyMyId = () => {
        if(myId) {
            navigator.clipboard.writeText(myId);
            const oldText = document.getElementById('conn-status').innerText;
            document.getElementById('conn-status').innerText = "ID Copied!";
            setTimeout(() => document.getElementById('conn-status').innerText = oldText, 2000);
        }
    };

    window.connectToPeer = () => { 
        const tid = document.getElementById('join-seed').value.trim(); 
        if(tid && tid !== myId && !connections[tid]) {
            amIPeer = true;
            const conn = peer.connect(tid, { reliable: true });
            setupConn(conn, true); 
            document.getElementById('conn-status').innerText = "Status: Connecting...";
        }
    };

    function disposeRemotePlayer(id) {
        if (remotePlayers[id]) {
            scene.remove(remotePlayers[id].mesh);
            remotePlayers[id].wheels.forEach(w => scene.remove(w));
            delete remotePlayers[id];
        }
    }

    function setupConn(conn, peerRole) {
        conn.on('open', () => {
            connections[conn.peer] = conn;
            document.getElementById('conn-status').innerText = "Status: Connected";
            document.getElementById('conn-status').style.color = "#00ff00";
            if(peerRole) conn.send({ type: 'REQ_SEED' });
        });
        conn.on('data', (d) => { 
            if(d.type === 'REQ_SEED' && !peerRole) conn.send({ type: 'SYNC_SEED', seed: currentWorldSeed });
            if(d.type === 'SYNC_SEED' && peerRole) performResetAndSync(d.seed);
            if(d.p) updateRemote(conn.peer, d); 
        });
        conn.on('close', () => { 
            disposeRemotePlayer(conn.peer);
            delete connections[conn.peer]; 
            document.getElementById('conn-status').innerText = "Status: Disconnected";
        });
        conn.on('error', () => { disposeRemotePlayer(conn.peer); delete connections[conn.peer]; });
    }

    function updateRemote(id, d) {
        if(!remotePlayers[id]) {
            const g = new THREE.Group(); 
            if(carModel) g.add(SkeletonUtils.clone(carModel));
            const tag = createNameTag(d.u || "Driver");
            g.add(tag);
            scene.add(g); 
            remotePlayers[id] = { mesh: g, wheels: [], nameTag: tag, tP: new THREE.Vector3(), tQ: new THREE.Quaternion(), tW: [] };
        }
        
        const rp = remotePlayers[id];
        
        // Late Spawning Wheels
        if(rp.wheels.length === 0 && wheelModel) {
            for (let i = 0; i < 4; i++) {
                const w = SkeletonUtils.clone(wheelModel);
                w.scale.set(WHEEL_RADIUS*0.8, WHEEL_RADIUS*0.8, WHEEL_RADIUS*0.8);
                scene.add(w);
                rp.wheels[i] = w;
            }
        }
        
        // Dynamic Name Update
        if(d.u && rp.nameTag.userData.name !== d.u) {
            rp.mesh.remove(rp.nameTag);
            rp.nameTag = createNameTag(d.u);
            rp.mesh.add(rp.nameTag);
        }

        rp.tP.set(d.p.x, d.p.y, d.p.z); 
        rp.tQ.set(d.q.x, d.q.y, d.q.z, d.q.w);
        if(d.w) rp.tW = d.w;
    }

    let drive = { throttle: 0, steer: 0, brake: false }, activePtr = null;
    const joyK = document.getElementById('joystick-knob'), joyW = document.getElementById('joystick-wrapper');
    joyW.onpointerdown = e => { activePtr = e.pointerId; handleJoy(e); };
    window.onpointermove = e => { if(e.pointerId === activePtr) handleJoy(e); };
    window.onpointerup = e => { if(e.pointerId === activePtr) { activePtr = null; joyK.style.transform = ''; drive.throttle = 0; drive.steer = 0; } };
    function handleJoy(e) {
        const r = joyW.getBoundingClientRect();
        let dx = e.clientX - (r.left + r.width/2), dy = e.clientY - (r.top + r.height/2);
        const d = Math.min(Math.sqrt(dx*dx + dy*dy), 45);
        if (d > 0) {
            joyK.style.transform = `translate(${(dx/Math.sqrt(dx*dx+dy*dy))*d}px, ${(dy/Math.sqrt(dx*dx+dy*dy))*d}px)`;
            drive.throttle = -dy/45; drive.steer = -dx/45;
        }
    }
    document.getElementById('brake-btn').onpointerdown = () => drive.brake = true;
    window.addEventListener('pointerup', e => { if(e.pointerId !== activePtr) drive.brake = false; });

    const clock = new THREE.Clock(), prevPos = new THREE.Vector3();
    let lastUpdatePos = new THREE.Vector3(0,0,0);
    let recoveryTimer = 0;

    const collisionPoints = [];
    for (let z = -2.8; z <= 2.8; z += 1.4) { 
        for (let x = -1.4; x <= 1.4; x += 1.4) { 
            for (let y = -0.8; y <= 0.8; y += 0.4) { 
                collisionPoints.push(new CANNON.Vec3(x, y, z));
            }
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta(), speed = vehicle.currentVehicleSpeedKmHour, absS = Math.abs(speed);

        if (chassisBody.position.y < -100) performResetAndSync(currentWorldSeed);

        const subSteps = 30; 
        const tStep = 1 / (60 * subSteps); 
        for (let i = 0; i < subSteps; i++) {
            world.step(tStep);
            collisionPoints.forEach(lp => {
                const wp = new CANNON.Vec3();
                chassisBody.quaternion.vmult(lp, wp);
                wp.vadd(chassisBody.position, wp);
                const floorY = getHeight(wp.x, wp.z);
                if (wp.y < floorY) {
                    const penetration = floorY - wp.y;
                    let forceScale = (recoveryTimer > 0.5) ? 800 : 240;
                    const forceMag = penetration * MASS * forceScale; 
                    chassisBody.applyImpulse(new CANNON.Vec3(0, forceMag * tStep, 0), wp.vsub(chassisBody.position));
                }
            });
        }

        const carUp = new CANNON.Vec3(0, 1, 0);
        chassisBody.quaternion.vmult(carUp, carUp);
        const uprightFactor = carUp.dot(new CANNON.Vec3(0, 1, 0));

        if (uprightFactor < 0.6) { 
            recoveryTimer += dt;
            if (recoveryTimer > 1.0) { 
                const rollAxis = new CANNON.Vec3();
                carUp.cross(new CANNON.Vec3(0, 1, 0), rollAxis);
                rollAxis.normalize();
                chassisBody.angularVelocity.x += rollAxis.x * 3.5 * (1.0 - uprightFactor);
                chassisBody.angularVelocity.z += rollAxis.z * 3.5 * (1.0 - uprightFactor);
                if (recoveryTimer < 1.1) chassisBody.velocity.y += 10;
                document.getElementById('recovery-status').innerText = "RECOVERING...";
            }
        } else {
            recoveryTimer = 0;
            document.getElementById('recovery-status').innerText = "STABLE";
        }

        const engineForce = (absS < MAX_SPEED_KMH) ? drive.throttle * 4.1e15 : 0;
        const bForce = drive.brake ? 1e18 : 0;
        chassisBody.linearDamping = drive.brake ? 0.999 : 0.05;

        for(let i=0; i<4; i++) { vehicle.applyEngineForce(engineForce, i); vehicle.setBrake(bForce, i); }
        vehicle.setSteeringValue(drive.steer * 0.08, 2); vehicle.setSteeringValue(drive.steer * 0.08, 3);

        localCarMesh.position.copy(chassisBody.position); 
        localCarMesh.quaternion.copy(chassisBody.quaternion);
        document.getElementById('speed-val').innerText = Math.round(absS).toLocaleString();
        document.getElementById('pos-x').innerText = Math.round(chassisBody.position.x).toLocaleString();
        document.getElementById('pos-z').innerText = Math.round(chassisBody.position.z).toLocaleString();

        vehicle.wheelInfos.forEach((w, i) => {
            vehicle.updateWheelTransform(i);
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(w.worldTransform.position);
                wheelMeshes[i].quaternion.copy(w.worldTransform.quaternion);
                wheelMeshes[i].children[0].rotateX((speed * dt) / WHEEL_RADIUS * 0.1 * ((i >= 2) ? -1 : 1));
            }
        });

        if (peer && myId && Object.keys(connections).length > 0) {
            const pkt = { p: chassisBody.position, q: chassisBody.quaternion, w: vehicle.wheelInfos.map(wi => ({ p: wi.worldTransform.position, q: wi.worldTransform.quaternion })), u: usernameInput.value };
            for (let id in connections) if(connections[id].open) connections[id].send(pkt);
        }
        
        for (let id in remotePlayers) { 
            const p = remotePlayers[id];
            p.mesh.position.lerp(p.tP, 0.2); 
            p.mesh.quaternion.slerp(p.tQ, 0.2); 
            if(p.wheels.length > 0 && p.tW) p.tW.forEach((wd, i) => { 
                if(p.wheels[i]) { p.wheels[i].position.lerp(wd.p, 0.2); p.wheels[i].quaternion.slerp(wd.q, 0.2); }
            });
        }

        if (chassisBody.position.distanceTo(lastUpdatePos) > 200) { syncTerrain(chassisBody.position.x, chassisBody.position.z); lastUpdatePos.copy(chassisBody.position); }
        camera.fov = 70 + (absS / 40); camera.updateProjectionMatrix();
        camera.position.add(new THREE.Vector3().subVectors(chassisBody.position, prevPos));
        orbit.target.copy(chassisBody.position); prevPos.copy(chassisBody.position);
        orbit.update(); renderer.render(scene, camera);
    }

    syncTerrain(0, 0); initMultiplayer(); animate();
</script>
</body>
</html>
